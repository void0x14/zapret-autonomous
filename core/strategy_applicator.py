"""
Strategy Applicator - The Real Deal
Applies iptables rules and spawns nfqws process to actually bypass DPI.
Implements Singleton pattern for global access.
"""
import subprocess
import shutil
import logging
import atexit
import shlex
import socket
import requests
from typing import Optional, List
from solver.heuristics import STRATEGIES

# Configuration
NFQUEUE_NUM = 200
NFQWS_PATH = shutil.which('nfqws') or '/usr/bin/nfqws'

class StrategyApplicator:
    """
    Manages iptables rules and nfqws process for actual DPI bypass.
    Should be used as a Singleton via get_applicator().
    """
    
    def __init__(self):
        self.current_process = None
        self.applied_rules = []
        # NOT using atexit - nfqws should persist after script exits
        # User will manually call 'zapret-cli.py stop' to cleanup
    
    def is_active(self) -> bool:
        """Check if bypass is currently active (process running)."""
        if self.current_process is None:
            return False
        if self.current_process.poll() is not None:
            # Process bitmiş/çökmüş
            self.current_process = None
            return False
        return True

    def apply(self, strategy_key: str, domains: List[str]) -> bool:
        """Apply a specific strategy for the given domains."""
        self.stop()  # Clean up existing processes/rules first
        
        logging.info(f"Applying strategy: {strategy_key} for {len(domains)} domains")
        
        if not self._apply_iptables(domains):
            logging.error("Failed to apply iptables rules")
            return False
            
        if not self._start_nfqws(strategy_key):
            logging.error("Failed to start nfqws")
            self._cleanup_iptables()
            return False
            
        return True
    
    def stop(self):
        """Stop current bypass (kill nfqws, remove rules). Safe to call multiple times."""
        if self.current_process:
            logging.info("Stopping nfqws...")
            self.current_process.terminate()
            try:
                self.current_process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self.current_process.kill()
            self.current_process = None
            logging.info("✓ nfqws stopped")
            
        self._cleanup_iptables()

    def _cleanup_iptables(self):
        """Remove all applied iptables rules in reverse order."""
        if self.applied_rules:
            logging.info("Removing iptables rules...")
            for rule in reversed(self.applied_rules):
                # Suppress output during cleanup
                subprocess.run(['iptables', '-t', 'mangle', '-D'] + rule, 
                             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.applied_rules = []
            
            # Flush specific queue rule just in case (Safety net)
            subprocess.run(['iptables', '-t', 'mangle', '-D', 'OUTPUT', 
                          '-p', 'tcp', '--dport', '443',
                          '-j', 'NFQUEUE', '--queue-num', str(NFQUEUE_NUM), '--queue-bypass'], 
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logging.info("✓ IPTables rules removed")

    def _resolve_ip(self, domain: str) -> Optional[str]:
        """Resolve IP. Priorities: System DNS > DoH Fallback."""
        # 1. System DNS (Trusting user's NextDNS/DoT setup)
        try:
            ip = socket.gethostbyname(domain)
            if not ip.startswith("0.") and ip != "127.0.0.1":
                return ip
        except:
            pass
            
        # 2. DoH Fallback (Cloudflare) - Only if system DNS fails
        try:
            resp = requests.get(
                "https://cloudflare-dns.com/dns-query",
                params={"name": domain, "type": "A"},
                headers={"Accept": "application/dns-json"},
                timeout=5, verify=False
            )
            data = resp.json()
            if "Answer" in data:
                for ans in data["Answer"]:
                    if ans.get("type") == 1: # A record
                        return ans.get("data")
        except:
            pass
        return None

    def _apply_iptables(self, domains: List[str]) -> bool:
        """Apply NFQUEUE rules for target domains using OUTPUT chain."""
        try:
            for domain in domains:
                # Resolve IP
                ip = self._resolve_ip(domain)
                if not ip:
                    logging.warning(f"Could not resolve {domain}, skipping iptables rule")
                    continue
                
                logging.info(f"Adding rule for {domain} -> {ip}")
                
                # Rule: OUTPUT chain for specific destination IP
                # This captures traffic generated by local processes (browsers)
                rule = [
                    'OUTPUT',
                    '-p', 'tcp', '--dport', '443',
                    '-d', ip,
                    '-j', 'NFQUEUE', '--queue-num', str(NFQUEUE_NUM), '--queue-bypass'
                ]
                
                subprocess.run(['iptables', '-t', 'mangle', '-I'] + rule, check=True)
                self.applied_rules.append(rule)
                
            return len(self.applied_rules) > 0
            
        except subprocess.CalledProcessError as e:
            logging.error(f"IPTables error: {e}")
            return False

    def _start_nfqws(self, strategy_key: str) -> bool:
        """Start nfqws process with the given strategy."""
        if strategy_key not in STRATEGIES:
            logging.error(f"Unknown strategy: {strategy_key}")
            return False
            
        strategy_cmd = STRATEGIES[strategy_key]["cmd"]
        
        # Build nfqws command - properly parse strategy_cmd with shlex
        cmd = [NFQWS_PATH, f'--qnum={NFQUEUE_NUM}'] + shlex.split(strategy_cmd)
        
        logging.info(f"Starting nfqws: {' '.join(cmd)}")
        
        try:
            self.current_process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True # Detach from terminal to prevent signal propagation
            )
            return True
        except Exception as e:
            logging.error(f"Failed to start nfqws: {e}")
            return False

# Global instance for Singleton pattern
_applicator_instance = None

def get_applicator() -> StrategyApplicator:
    """Get the singleton StrategyApplicator instance."""
    global _applicator_instance
    if _applicator_instance is None:
        _applicator_instance = StrategyApplicator()
    return _applicator_instance
